
<!DOCTYPE html>

<html lang="sr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Рекурзивне функције &#8212; документација Компоновање рачунарских програма прво штампано</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pyramid.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/translations.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Индекс" href="../genindex.html" />
    <link rel="search" title="Претрага" href="../search.html" />
    <link rel="next" title="Апстракција подацима" href="../%D0%B3%D0%BB%D0%B0%D0%B2%D0%B02/index.html" />
    <link rel="prev" title="Функције вишег реда" href="6-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%98%D0%B5-%D0%B2%D0%B8%D1%88%D0%B5%D0%B3-%D1%80%D0%B5%D0%B4%D0%B0.html" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head><body>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Навигација</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">индекс</a></li>
        <li class="right" >
          <a href="../%D0%B3%D0%BB%D0%B0%D0%B2%D0%B02/index.html" title="Апстракција подацима"
             accesskey="N">напред</a> |</li>
        <li class="right" >
          <a href="6-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%98%D0%B5-%D0%B2%D0%B8%D1%88%D0%B5%D0%B3-%D1%80%D0%B5%D0%B4%D0%B0.html" title="Функције вишег реда"
             accesskey="P">назад</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">документација Компоновање рачунарских програма прво штампано</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Апстракција функцијама</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Рекурзивне функције</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="recursivefunctions">
<span id="id1"></span><h1>Рекурзивне функције<a class="headerlink" href="#recursivefunctions" title="Permalink to this headline">¶</a></h1>
<p>Функција је <em>рекурзивна</em> ако унутар тела функције позива саму себе било директно или индиректно. Другим речима, ток извршења тела рекурзивне функције може захтевати позив те функције поново. Рекурзивне функције у Пајтону не користе никакву посебну синтаксу, али захтевају известан напор да се разумеју и напишу.</p>
<p>Почећемо примером задатка: написати функцију која сабира цифре природног броја. Приликом пројектовања рекурзивне функције траже се начини да се проблем растави на једноставније потпроблеме. У овом конкретном случају, оператори <code class="docutils literal notranslate"><span class="pre">%</span></code> и <code class="docutils literal notranslate"><span class="pre">//</span></code> се могу користити да се број раздвоји на два дела: цифру најмање тежине и остатак броја.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">18117</span> <span class="o">%</span> <span class="mi">10</span>
<span class="go">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">18117</span> <span class="o">//</span> <span class="mi">10</span>
<span class="go">1811</span>
</pre></div>
</div>
<p>Збир цифара броја 18117 је <span class="math notranslate nohighlight">\(1+8+1+1+7=18\)</span>. Баш као што је могуће раздвојити број, може се раздвојити и овај збир на последњу цифру, 7, и збир свих цифара изузев последње, <span class="math notranslate nohighlight">\(1+8+1+1=11\)</span>. Ово раздвајање даје алгоритам: да се саберу цифре броја <code class="docutils literal notranslate"><span class="pre">n</span></code>, додати његову последњу цифру <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">%</span> <span class="pre">10</span></code> на збир цифара броја <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">//</span> <span class="pre">10</span></code>. Постоји један посебан случај: ако је број једноцифрен, тада је збир његових цифара управо сам тај број. Овај алгоритам може се имплементирати као рекурзивна функција.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">збирЦифара</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">... </span>    <span class="sd">&quot;&quot;&quot;Враћа збир цифара природног броја n.&quot;&quot;&quot;</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">n</span>
<span class="gp">... </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">свеСемПоследњеЦифре</span><span class="p">,</span> <span class="n">последњаЦифра</span> <span class="o">=</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">10</span><span class="p">,</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">10</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">збирЦифара</span><span class="p">(</span><span class="n">свеСемПоследњеЦифре</span><span class="p">)</span> <span class="o">+</span> <span class="n">последњаЦифра</span>
</pre></div>
</div>
<p>Оваква дефиниција <code class="docutils literal notranslate"><span class="pre">збирЦифара</span></code> је истовремено и потпуна и исправна упркос томе што је функција <code class="docutils literal notranslate"><span class="pre">збирЦифара</span></code> позвана унутар сопственог тела. Задатак израчунавања збира цифара броја је подељен на два корака: збир свих цифара изузев последње и додавања последње цифре. Оба ова корака су једноставнија од почетног задатка. Функција је рекурзивна зато што је први корак заправо исти тип задатка као и оригинални задатак. То јест, <code class="docutils literal notranslate"><span class="pre">збирЦифара</span></code> је функција која је потребна да би се имплементирао <code class="docutils literal notranslate"><span class="pre">збирЦифара</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">збирЦифара</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="go">9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">збирЦифара</span><span class="p">(</span><span class="mi">18117</span><span class="p">)</span>
<span class="go">18</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">збирЦифара</span><span class="p">(</span><span class="mi">9437184</span><span class="p">)</span>
<span class="go">36</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">збирЦифара</span><span class="p">(</span><span class="mi">11408855402054064613470328848384</span><span class="p">)</span>
<span class="go">126</span>
</pre></div>
</div>
<p>Могуће је тачно разумети како ова рекурзивна функција бива позивана користећи окружење модела израчунавања. Нису неопходна никаква додатна нова правила.</p>
<p>Када се <code class="docutils literal notranslate"><span class="pre">def</span></code> наредба изврши, назив <code class="docutils literal notranslate"><span class="pre">збирЦифара</span></code> је повезан на новостворену функцију, али тело те функције још увек није извршено. Због тога, кружна природа функције <code class="docutils literal notranslate"><span class="pre">збирЦифара</span></code> још увек не представља проблем. Затим се <code class="docutils literal notranslate"><span class="pre">збирЦифара</span></code> позива над аргументом 738, рецимо:</p>
<ol class="arabic simple">
<li><p>Ствара се локални оквир за <code class="docutils literal notranslate"><span class="pre">збирЦифара</span></code> у коме је <code class="docutils literal notranslate"><span class="pre">n</span></code> повезано на 738 и тело функције <code class="docutils literal notranslate"><span class="pre">збирЦифара</span></code> се извршава у окружењу које започиње тим оквиром.</p></li>
<li><p>Како 738 није мање од 10, наредба доделе вредности се извршава делећи број 738 на 73 и 8.</p></li>
<li><p>У <code class="docutils literal notranslate"><span class="pre">return</span></code> наредби која следи, <code class="docutils literal notranslate"><span class="pre">збирЦифара</span></code> се позива над аргументом 73, што је вредност променљиве <code class="docutils literal notranslate"><span class="pre">свеСемПоследњеЦифре</span></code> у тренутном окружењу.</p></li>
<li><p>Други локални оквир за <code class="docutils literal notranslate"><span class="pre">збирЦифара</span></code> је створен, али овога пута са <code class="docutils literal notranslate"><span class="pre">n</span></code> увезаним на 73. Тело функције <code class="docutils literal notranslate"><span class="pre">збирЦифара</span></code> се поново извршава, сада у новом окружењу које почиње овим оквиром.</p></li>
<li><p>Пошто 73 такође није мање од 10, број 73 се дели на 7 и 3 и <code class="docutils literal notranslate"><span class="pre">збирЦифара</span></code> бива позван над 7 што је вредност променљиве <code class="docutils literal notranslate"><span class="pre">свеСемПоследњеЦифре</span></code> вредноване у овом оквиру.</p></li>
<li><p>Трећи локални оквир за функцију <code class="docutils literal notranslate"><span class="pre">збирЦифара</span></code> је створен са <code class="docutils literal notranslate"><span class="pre">n</span></code> повезаним на 7.</p></li>
<li><p>У окружењу које започиње овим оквиром провера <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&lt;</span> <span class="pre">10</span></code> је тачна те је зато 7 повратна вредност.</p></li>
<li><p>У другом локалном оквиру, ова враћена вредност 7 се сабира са 3, што је вредност променљиве <code class="docutils literal notranslate"><span class="pre">последњаЦифра</span></code>, да би се вратила вредност 10.</p></li>
<li><p>У првом локалном оквиру, ова враћена вредност 10 се сабира са 8, што је вредност променљиве <code class="docutils literal notranslate"><span class="pre">последњаЦифра</span></code>, да би се вратила вредност 18.</p></li>
</ol>
<p>Упркос својој кружној одлици, ова рекурзивна функција примењује се исправно зато што бива примењена два пута, али с различитим аргументима. Штавише, други позив функције био је једноставни случај почетног задатка да се израчуна збир цифара броја. При позиву функције <code class="docutils literal notranslate"><span class="pre">збирЦифара</span></code> над произвољно великим аргументом, може се једноставним скицирањем окружења показати да сваки наредни позив функције <code class="docutils literal notranslate"><span class="pre">збирЦифара</span></code> узима мањи аргумент од претходног, све док се најзад не дође до једноцифреног улаза.</p>
<p>Овај пример такође илуструје како се функције које имају једноставна тела могу развити у сложене процесе израчунавања користећи рекурзију.</p>
<div class="section" id="anatomyofrecursivefunctions">
<span id="id2"></span><h2>Анатомија рекурзивних функција<a class="headerlink" href="#anatomyofrecursivefunctions" title="Permalink to this headline">¶</a></h2>
<p>У телу многих рекурзивних функција проналази се заједнички шаблон. Тело започиње основним случајем, условном наредбом која дефинише понашање функције за тривијалне улазе, односно аргументе најједноставније за обраду. У примеру <code class="docutils literal notranslate"><span class="pre">збирЦифара</span></code>, основни случај је сваки једноцифрен аргумент који уједно представља и повратну вредност. Поједине рекурзивне функције ће имати више основних случајева.</p>
<p>Основни случајеви су праћени од стране једног или више рекурзивних позива. Рекурзивни позиви увек упрошћавају почетни проблем. Рекурзивне функције изражавају израчунавање кроз постепено поједностављивање проблема. На пример, сабирање цифара броја 7 је једноставније од сабирање цифара броја 73, што је опет једноставније од сабирања цифара броја 738. За сваки следећи позив функције, преостало је мање посла да се обави.</p>
<p>Рекурзивне функције често решавају проблеме на другачији начин од итеративних приступа који су коришћени раније. Размотрити функцију <code class="docutils literal notranslate"><span class="pre">факт</span></code> која израчунава факторијел од <code class="docutils literal notranslate"><span class="pre">n</span></code>, где примера ради <code class="docutils literal notranslate"><span class="pre">факт(4)</span></code> рачуна <span class="math notranslate nohighlight">\(4!=4\cdot3\cdot2\cdot1=24\)</span>.</p>
<p>Природна имплементација коришћењем <code class="docutils literal notranslate"><span class="pre">while</span></code> наредбе акумулира производ множећи све природне бројеве до <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">фактИтер</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">производ</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="k">while</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
<span class="gp">... </span>       <span class="n">производ</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">производ</span> <span class="o">*</span> <span class="n">k</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">производ</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">фактИтер</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">24</span>
</pre></div>
</div>
<p>С друге стране, рекурзивна имплементација факторијела може изразити <code class="docutils literal notranslate"><span class="pre">факт(n)</span></code> преко <code class="docutils literal notranslate"><span class="pre">факт(n-1)</span></code>, што је једноставнији проблем. Основни рекурзивни случај је најједноставнији облик проблема, односно: <code class="docutils literal notranslate"><span class="pre">факт(1)</span></code> је 1.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">факт</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">... </span>       <span class="k">return</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>       <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">факт</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">факт</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">24</span>
</pre></div>
</div>
<p>Претходне две факторијел фукнције се концептуално разликују. Итеративна функција постепено гради резултат почевши од основног случаја за 1 све до коначног производа кроз узастопна множења сваког чиниоца. Рекурзивна функција, у другу руку, гради резултат директно од последњег чиниоца, <code class="docutils literal notranslate"><span class="pre">n</span></code>, и резултата једноставнијег проблема, <code class="docutils literal notranslate"><span class="pre">факт(n-1)</span></code>.</p>
<p>Како се рекурзија „одмотава” кроз сукцесивне примене <code class="docutils literal notranslate"><span class="pre">факт</span></code> фукције на све једноставније и једноставније инстанце проблема, резултат најзад бива изграђен почевши од основног случаја. Рекурзија се завршава прослеђивањем аргумента 1 функцији <code class="docutils literal notranslate"><span class="pre">факт</span></code>. Резултат сваког позива зависи од наредног све док се не стигне до основног случаја.</p>
<p>Исправност ове рекурзивне фукнције је лако потврдити преко стандардне дефиниције математичке функције факторијел:</p>
<div class="math notranslate nohighlight">
\[\begin{split}(n-1)!&amp;=(n-1)\cdot(n-2)\cdot\cdots\cdot3\cdot2\cdot1\\
n!&amp;=n\cdot(n-1)\cdot(n-2)\cdot\cdots\cdot3\cdot2\cdot1\\
n!&amp;=n\cdot(n-1)!\end{split}\]</div>
<p>Иако је могуће размотати рекурзију користећи постојећи модел израчунавања, често је јасније размишљати о рекурзивним позивима као функционалним апстракцијама. То јест, не треба бринути о томе како је <code class="docutils literal notranslate"><span class="pre">факт(n-1)</span></code> имплементирано у телу функције <code class="docutils literal notranslate"><span class="pre">факт</span></code>, већ једноставно веровати да рачуна факторијел аргумента <code class="docutils literal notranslate"><span class="pre">n-1</span></code>. Третирање рекурзивних позива као функционалне апстракције је назван <cite>рекурзивни скок вере</cite>. Функција се дефинише преко саме себе и приликом провере исправности функције просто се верује, односно претпоставља да једноставнији случај ради исправно. У овом примеру верује се да <code class="docutils literal notranslate"><span class="pre">факт(n-1)</span></code> тачно рачуна <span class="math notranslate nohighlight">\((n-1)!\)</span> па се стога само проверава да је <span class="math notranslate nohighlight">\(n!\)</span> исправно израчунато под условом да је претходна претпоставка тачна. На овај начин, провера исправности рекурзивне функције је облик индуктивног доказа.</p>
<p>Функције <code class="docutils literal notranslate"><span class="pre">фактИтер</span></code> и <code class="docutils literal notranslate"><span class="pre">факт</span></code> се такође разликују зато што се у првопоменутој имплементацији морају увести две додатне променљиве, <code class="docutils literal notranslate"><span class="pre">производ</span></code> и <code class="docutils literal notranslate"><span class="pre">k</span></code> које нису неопходне у рекурзивној имплементацији. Итеративне функције углавном морају успоставити и одржавати нека локална стања која се мењају током читавог рачунања. У сваком тренутку, то стање карактерише резултат обављеног посла као и преосталу количину посла. На пример, када је <code class="docutils literal notranslate"><span class="pre">k</span></code> једнако 3, а <code class="docutils literal notranslate"><span class="pre">производ</span></code> једнак 2, преостају још два члана да се обраде, 3 и 4. С друге стране, <code class="docutils literal notranslate"><span class="pre">факт</span></code> функција је одређена једним аргументом <code class="docutils literal notranslate"><span class="pre">n</span></code>. Стање израчунавања је у потпуности садржано унутар структуре окружења, тачније кроз повратне вредности које имају улогу производа и повезују <code class="docutils literal notranslate"><span class="pre">n</span></code> на различите вредности у различитим оквирима уместо да експлицитно прате <code class="docutils literal notranslate"><span class="pre">k</span></code>.</p>
<p>Рекурзивне функције користе правила вредновања позивних израза да повежу имена на вредности притом често избегавајући сметње проузроковане доделама локалних имена унутар итерације. Из овог разлога рекурзивне функције се лакше дефинишу на исправан начин. Међутим, учење да се препознају процеси израчунавања развијени из рекурзивних функције свакако захтевају вежбу.</p>
</div>
<div class="section" id="mutualrecursion">
<span id="id3"></span><h2>Међусобна рекурзија<a class="headerlink" href="#mutualrecursion" title="Permalink to this headline">¶</a></h2>
<p>Када је рекурзивна процедура подељена између две функције које позивају једна другу, каже се да су функције <cite>међусобно рекурзивне</cite>. Као пример размотрити следећу дефиницију парности и непарности за природне бројеве:</p>
<ul class="simple">
<li><p>број је паран ако је за један већи од непарног броја;</p></li>
<li><p>број је непаран ако је за један већи од парног броја;</p></li>
<li><p>нула је парна.</p></li>
</ul>
<p>Користећи ову дефиницију, могуће је имплементирати међусобно рекурзивне функције које одређују да ли је број паран или непаран:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">јеПаран</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="kc">True</span>
<span class="gp">... </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">јеНепаран</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">јеНепаран</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="kc">False</span>
<span class="gp">... </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">јеПаран</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">јеПаран</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Међусобно рекурзивне функције могу се претворити у појединачно рекурзивне функције кроз пробијање границе апстракције између две функције. У овом примеру, тело функције <code class="docutils literal notranslate"><span class="pre">јеНепаран</span></code> може се припојити телу функције <code class="docutils literal notranslate"><span class="pre">јеПаран</span></code> водећи рачуна да се <code class="docutils literal notranslate"><span class="pre">n</span></code> унутар тела функције <code class="docutils literal notranslate"><span class="pre">јеНепаран</span></code> замени са <code class="docutils literal notranslate"><span class="pre">n-1</span></code> како би одразио прослеђени јој аргумент:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">јеПаран</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="kc">True</span>
<span class="gp">... </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">return</span> <span class="kc">False</span>
<span class="gp">... </span>        <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">return</span> <span class="n">јеПаран</span><span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Као таква, међусобна рекурзија није ништа тајанственија нити моћнија од једноставне рекурзије, али пружа механизам одржавања апстракције унутар компликованих рекурзивних програма.</p>
</div>
<div class="section" id="printinginrecursivefunctions">
<span id="id4"></span><h2>Испис унутар рекурзивних функција<a class="headerlink" href="#printinginrecursivefunctions" title="Permalink to this headline">¶</a></h2>
<p>Рачунски процес развијен кроз рекурзивну функцију често се може осликати користећи <code class="docutils literal notranslate"><span class="pre">print</span></code> позиве. Као пример, биће иплементирана функција <code class="docutils literal notranslate"><span class="pre">каскада</span></code> која исписује све префиксе неког броја од најдужег ка најмањем и натраг до најдужег.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">каскада</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">... </span>    <span class="sd">&quot;&quot;&quot;Исписује каскаду префикса броја n.&quot;&quot;&quot;</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">каскада</span><span class="p">(</span><span class="n">n</span><span class="o">//</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">каскада</span><span class="p">(</span><span class="mi">2023</span><span class="p">)</span>
<span class="go">2023</span>
<span class="go">202</span>
<span class="go">20</span>
<span class="go">2</span>
<span class="go">20</span>
<span class="go">202</span>
<span class="go">2023</span>
</pre></div>
</div>
<p>У овој рекурзивној функцији, основни случај јесте једноцифрени број, који се исписује. Иначе, рекурзивни позив је постављен између два <code class="docutils literal notranslate"><span class="pre">print</span></code> позива.</p>
<p>Није строг услов да се основни случај изрази пре рекурзивних позива. Заправо, ова функција се може компактније изразити уз опаску да се <code class="docutils literal notranslate"><span class="pre">print(n)</span></code> понавља у оба случаја условне наредбе те јој стога може претходити.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">каскада</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">... </span>    <span class="sd">&quot;&quot;&quot;Исписује каскаду префикса броја n.&quot;&quot;&quot;</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">каскада</span><span class="p">(</span><span class="n">n</span><span class="o">//</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>Као други пример међусобне рекурзије, размотрити игру у којој се на почетку на столу налази <span class="math notranslate nohighlight">\(n\)</span> облутака. Два играча у сваком кругу узимају по један или два облутка са стола. Победник је онај играч који узме последњи облутак. Претпоставити да играчи А и Б играју ову игру, сваки од њих користећи просту стратегију:</p>
<ul class="simple">
<li><p>Играч А увек узима по један облутак;</p></li>
<li><p>Играч Б узима два облутка ако је на столу паран број облутака, а иначе један.</p></li>
</ul>
<p>Уколико је дато <span class="math notranslate nohighlight">\(n\)</span> облутака и ирач А започиње игру, ко ће победити?</p>
<p>Природно растављање овог задатка јесте кроз раздвајање сваке од стратегија у засебну функцију. Ово дозвољава потенцијалну промену сваке од стратегија без утицаја на ону другу тако одржавајући апстрактну преграду између њих. Да би се укључила кружна природа игре, ове две функције позивају једна другу на крају сваког круга.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">играчА</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Играч Б побеђује!&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">играчБ</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">играчБ</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Играч А побеђује!&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">elif</span> <span class="n">јеПаран</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">играчА</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">играчА</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">играчА</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">Играч Б побеђује!</span>
</pre></div>
</div>
<p>Унутар тела функције <code class="docutils literal notranslate"><span class="pre">играчБ</span></code> примећују се вишеструки рекурзивни позиви. Међутим, у овом случају, сваки позив функције <code class="docutils literal notranslate"><span class="pre">играчБ</span></code> позива функцију <code class="docutils literal notranslate"><span class="pre">играчА</span></code> највише једном. У следећем одељку биће размотрено шта се дешава када један позив функције прави вишеструке директне рекурзивне позиве.</p>
</div>
<div class="section" id="treerecursion">
<span id="id5"></span><h2>Рекурзивно стабло<a class="headerlink" href="#treerecursion" title="Permalink to this headline">¶</a></h2>
<p>Још један уобичајени образац израчунавања јесте такозвано рекурзивно стабло или стабло рекурзије у ком функција позива саму себе више од једном. Као пример размотрити израчунавање низа Фибоначијевих бројева у коме сваки члан представља збир претходна два.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">фиб</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">0</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">фиб</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">фиб</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">фиб</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
<p>У поређењу са претходним покушајима, ова рекурзивна дефиниција је јако привлачна јер тачно одражава опште познату дефиницију Фибоначијевих бројева. Размотрити образац израчунавања који је резултат извршавања функције <code class="docutils literal notranslate"><span class="pre">фиб(6)</span></code>, приказан у наставку. Да би се израчунао <code class="docutils literal notranslate"><span class="pre">фиб(6)</span></code>, израчунавају се најпре <code class="docutils literal notranslate"><span class="pre">фиб(5)</span></code> и <code class="docutils literal notranslate"><span class="pre">фиб(4)</span></code>. Да би се израчунао <code class="docutils literal notranslate"><span class="pre">фиб(5)</span></code>, израчунавају се <code class="docutils literal notranslate"><span class="pre">фиб(4)</span></code> и <code class="docutils literal notranslate"><span class="pre">фиб(3)</span></code>. Генерално гледано, овај поступак израчунавања изгледа попут стабла (дијаграм у наставку није потпуни дијаграм окружења, већ поједностављени приказ поступка израчунавања). Свака плава тачка означава завршено израчунавање Фибоначијевог броја у процесу проласка кроз ово стабло.</p>
<img alt="../_images/fib.png" class="align-center" src="../_images/fib.png" />
<p>За функцију са вишеструким рекурзивним позивима се каже да представља <em>рекурзивно стабло</em> због тога што се сваки позив грана на више мањих позива од који се сваки даље рачва у још мање позиве, баш као што и гране дрвета постају мање и бројније како се шире од стабла. Ова функција је поучна као прототипска рекурзија стабла, али је ужасно неефикасан начин за одређивање Фибоначијевог низа јер врши толико сувишних израчунавања. Треба приметити да је целокупно израчунавање <code class="docutils literal notranslate"><span class="pre">фиб(4)</span></code>, што је готово половина посла, дуплирано. У ствари, није тешко показати да ће функција израчунати <code class="docutils literal notranslate"><span class="pre">фиб(1)</span></code> или <code class="docutils literal notranslate"><span class="pre">фиб(2)</span></code> (што представља број листова у стаблу) тачно <code class="docutils literal notranslate"><span class="pre">фиб(n+1)</span></code> пута. Да би се уопште схватило до које мере је ово лоше и неефикасно, лако се може показати да вредност <code class="docutils literal notranslate"><span class="pre">фиб(n)</span></code> расте експоненцијално са порастом <code class="docutils literal notranslate"><span class="pre">n</span></code>. Рецимо, <code class="docutils literal notranslate"><span class="pre">фиб(40)</span></code> је 63’245’986! Горња функција извршава кораке чији број расте експоненцијално са улазом.</p>
<p>Већ је показано да је могуће дефинисати функцију која израчунава Фибоначијеве бројеве без рекурзивног стабла. Заправо, претходни покушаји су били далеко ефикаснији, што је тема која ће бити разматрана нешто касније. Претходно приказана итеративна имплементација Фибоначијевих бројева, поновљена је овде ради боље прегледности.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">фибИтеративно</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">... </span>    <span class="sd">&quot;&quot;&quot;Израчунава n-ти Фибоначијев број, за n &gt;= 2.&quot;&quot;&quot;</span>
<span class="gp">... </span>    <span class="n">претходни</span><span class="p">,</span> <span class="n">тренутни</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>   <span class="c1"># први и други Фибоначијев број</span>
<span class="gp">... </span>    <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span>                        <span class="c1"># тренутни Фибоначијев број</span>
<span class="gp">... </span>    <span class="k">while</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">претходни</span><span class="p">,</span> <span class="n">тренутни</span> <span class="o">=</span> <span class="n">тренутни</span><span class="p">,</span> <span class="n">претходни</span> <span class="o">+</span> <span class="n">тренутни</span>
<span class="gp">... </span>        <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">тренутни</span>
</pre></div>
</div>
<p>Стање које се у овом случају мора одржавати састоји се од тренутног и претходног Фибоначијевог броја, заједно са индексом тренутног броја. Ова дефиниција не одражава стандардну математичку дефиницију Фибоначијевих бројева тако јасно као рекурзивни приступ. Међутим, количина израчунавања потребна у итеративној имплементацији само је линеарна у односу на <code class="docutils literal notranslate"><span class="pre">n</span></code>, а не експоненцијална. Чак и за мале вредности <code class="docutils literal notranslate"><span class="pre">n</span></code>, ова разлика може бити огромна.</p>
<p>Из ове разлике не треба закључити да су поступци који укључују рекурзивна стабла бескорисни. Када се узму у обзир поступци који оперишу над хијерархијски структурираним подацима, а не бројевима, биће откривено да су рекурзивна стабла врло природно и моћно средство. Осим тога, поступци који укључују рекзурзивна стабла често се могу учинити далеко ефикаснији, као што ће бити приказано у трећем поглављу.</p>
<p>У наставку ће бити приказан проблем за који је решење преко стабла рекурзије знатно једноставније од било које итеративне алтернативе.</p>
</div>
<div class="section" id="examplepartitions">
<span id="id6"></span><h2>Пример: Партиције<a class="headerlink" href="#examplepartitions" title="Permalink to this headline">¶</a></h2>
<p>Број партиција природног броја <span class="math notranslate nohighlight">\(n\)</span>, користећи се сабирцима мањим или једнаким од <span class="math notranslate nohighlight">\(m\)</span>, је број начина на који се број <span class="math notranslate nohighlight">\(n\)</span> може изразити као збир природних бројева не већих од <span class="math notranslate nohighlight">\(m\)</span> у неопадајућем редоследу. На пример, број партиција броја 6 користећи се деловима не већим од 4 јесте девет.</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(6 = 2 + 4\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(6 = 1 + 1 + 4\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(6 = 3 + 3\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(6 = 1 + 2 + 3\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(6 = 1 + 1 + 1 + 3\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(6 = 2 + 2 + 2\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(6 = 1 + 1 + 2 + 2\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(6 = 1 + 1 + 1 + 1 + 2\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(6 = 1 + 1 + 1 + 1 + 1 + 1\)</span></p></li>
</ol>
<p>Биће дефинисана функција <code class="docutils literal notranslate"><span class="pre">бројПартиција(n,</span> <span class="pre">m)</span></code> која враћа број различитих партиција аргумента <code class="docutils literal notranslate"><span class="pre">n</span></code> користећи делове мање или једнаке од <code class="docutils literal notranslate"><span class="pre">m</span></code>. Ова функција има једноставно решење користећи се рекурзивним стаблом које је засновано на следећем запажању:</p>
<p>Број начина на који се може партиционисати <span class="math notranslate nohighlight">\(n\)</span> користећи бројеве не веће од <span class="math notranslate nohighlight">\(m\)</span> једнак је:</p>
<ol class="arabic simple">
<li><p>броју начина да се партиционише <span class="math notranslate nohighlight">\(n-m\)</span> користећи делове мање или једнаке од <span class="math notranslate nohighlight">\(m\)</span>, и</p></li>
<li><p>броју начина да се партиционише <span class="math notranslate nohighlight">\(n\)</span> користећи делове не веће од <span class="math notranslate nohighlight">\(m-1\)</span>.</p></li>
</ol>
<p>Да би се схватило зашто је претходно тврђење тачно, треба уочити да се укупан број начина за партиционисање <span class="math notranslate nohighlight">\(n\)</span> може поделити у два дисјунктна подскупа: први који садржи макар једно <span class="math notranslate nohighlight">\(m\)</span> и други који не садржи ниједно. Штавише, свако партиционисање из првог подскупа јесте заправо партиција броја <span class="math notranslate nohighlight">\(n-m\)</span> праћена <span class="math notranslate nohighlight">\(m\)</span> као последњим сабирком. У горњем примеру, прве две партиције садрже 4, док осталих седам не садржи.</p>
<p>Стога, могуће је рекурзивно упростити проблем партиционисања <span class="math notranslate nohighlight">\(n\)</span> користећи бројеве мање или једнаке <span class="math notranslate nohighlight">\(m\)</span> на два једноставнија потпроблема: (1) партиционисање мањег броја <span class="math notranslate nohighlight">\(n-m\)</span>, и (2) партиционисање са мањим саставним деловима не већим од <span class="math notranslate nohighlight">\(m-1\)</span>.</p>
<p>Да би се довршила имплементација, неопходно је назначити и следеће основне случајеве:</p>
<ol class="arabic">
<li><p>Постоји један начин да се партиционише 0 који не садржи ниједан сабирак.</p></li>
<li><p>Постоји нула начина да се партиционишу негативни бројеви.</p></li>
<li><p>Не постоји начин да се природан број партиционише непозитивним бројевима.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">бројПартиција</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
<span class="gp">... </span>    <span class="sd">&quot;&quot;&quot;Враћа број партиција броја n користећи сабирке не веће од m.&quot;&quot;&quot;</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="k">elif</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">0</span>
<span class="gp">... </span>    <span class="k">elif</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">0</span>
<span class="gp">... </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">бројПартиција</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">+</span> <span class="n">бројПартиција</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">бројПартиција</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">бројПартиција</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">бројПартиција</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="go">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">бројПартиција</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
<span class="go">176</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">бројПартиција</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="go">627</span>
</pre></div>
</div>
</li>
</ol>
<p>Може се размишљати о стаблима рекурзије као о истраживању различитих могућности. У овом конкретном случају, истражује се могућност да се користе делови величине <span class="math notranslate nohighlight">\(m\)</span> и могућност да се не користе. Први и други рекурзивни позив управо одговарају овим могућностима.</p>
<p>Имплементација ове функције без рекурзије била би знатно запетљанија. Заинтересовани читаоци се охрабрују да покушају.</p>
</div>
<div class="section" id="examplecountingchange">
<span id="id7"></span><h2>Пример: Враћање кусура<a class="headerlink" href="#examplecountingchange" title="Permalink to this headline">¶</a></h2>
<p>Размотримо следеће хипотетичко питање: да ли сте се икада запитали на колико различитих начина у продавници можете добити кусур у висини одређеног износа користећи кованице од 1, 2, 5, 10 и 20 динара? Односно још уопштеније, може ли се написати функција за израчунавање броја начина за враћање било које унапред задате новчане вредности?</p>
<p>Овај проблем има једноставно решење у виду рекурзивне функције. Претпоставимо да вредности новчића, тј. кованица, имамо распоређене по неком редоследу (рецимо од виших ка нижим). Тада важи следећа релација:</p>
<p>Број начина за враћање кусура <span class="math notranslate nohighlight">\(k\)</span> користећи <span class="math notranslate nohighlight">\(n\)</span> врста кованица једнак је:</p>
<ul class="simple">
<li><p>број начина за враћање кусура <span class="math notranslate nohighlight">\(k\)</span> користећи све кованице изузев прве, плус</p></li>
<li><p>број начина за враћање кусура <span class="math notranslate nohighlight">\(k-d\)</span> коришћењем свих <span class="math notranslate nohighlight">\(n\)</span> врста кованица, где је <span class="math notranslate nohighlight">\(d\)</span> вредност прве кованице.</p></li>
</ul>
<p>Да би се увидело зашто претходна тврдња важи, треба запазити да се начини враћања кусура могу поделити у два скупа: они који не користе ниједан новчић прве вредности и они које то чине. Према томе, укупан број начина за враћање одређеног износа кусура једнак је броју начина за враћање износа кусура без употребе прве кованице из низа, плус број начина за враћање под претпоставком да се користи први новчић. Међутим, овај последњи број једнак је броју начина за враћање износа кусура који преостаје након употребе прве кованице у низу.</p>
<p>Дакле, може се рекурзивно смањити проблем враћања задатог износа кусура на проблем враћања мањих износа користећи мањи број кованица. Треба пажљиво размислити и размотрити претходно правило смањења и прихватити да се оно може искористити за описивање алгоритма ако се наведу и следећи специјални случајеви:</p>
<ul class="simple">
<li><p>Ако је <span class="math notranslate nohighlight">\(k\)</span> тачно 0, то би се требало рачунати као један начин за враћање кусура.</p></li>
<li><p>Ако је <span class="math notranslate nohighlight">\(k\)</span> мање од 0, то би се требало рачунати као 0 начина за враћање кусура.</p></li>
<li><p>Ако је <span class="math notranslate nohighlight">\(n\)</span> једнако 0, то би се такође требало рачунати као 0 начина за враћање кусура.</p></li>
</ul>
<p>Овај опис може се лако превести у рекурзиван поступак:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">кусур</span><span class="p">(</span><span class="n">износ</span><span class="p">,</span> <span class="n">апоени</span><span class="p">):</span>
<span class="gp">... </span>    <span class="sd">&quot;&quot;&quot; износ:  произвољан природан броj;</span>
<span class="gp">... </span><span class="sd">        апоени: низ или поворка природних броjева;</span>
<span class="gp">... </span><span class="sd">        враћа:  броj начина да се врати износ користећи апоене.&quot;&quot;&quot;</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">износ</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">износ</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">апоени</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">0</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">кусур</span><span class="p">(</span><span class="n">износ</span> <span class="o">-</span> <span class="n">апоени</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">апоени</span><span class="p">)</span> <span class="o">+</span> <span class="n">кусур</span><span class="p">(</span><span class="n">износ</span><span class="p">,</span> <span class="n">апоени</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
</pre></div>
</div>
<p>Сада се може претходна функција употребити да се одговори на питање на колико начина је могуће кованицама вратити кусур од 100 динара:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">кусур</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">])</span>
<span class="go">4111</span>
</pre></div>
</div>
<p>Функција <code class="docutils literal notranslate"><span class="pre">кусур</span></code> генерише рекурзивно стабло са редундансама сличним онима у првој имплементацији <code class="docutils literal notranslate"><span class="pre">фиб</span></code> функције. (Требаће доста времена да се израчуна 4111 начина.) С друге стране, није очигледно како испројектовати бољи и ефикаснији алгоритам за израчунавање резултата, а овај проблем оставља се као изазов читаоцу. Запажање да рекурзивни поступак може бити крајње неефикасан, иако га је често лако описати и разумети, навело је људе да предложе идеју о преузимању најбољих ствари из оба света пројектовањем такозваног „паметног преводиоца” који би трансформисао рекурзивна стабла у ефикасније поступке израчунавања којима би се долазило до истог резултата.</p>
<p>Један приступ у савладавању редундантних и сувишних израчунавања је сређивање ствари тако да се у току израчунавања аутоматски прави и попуњава табела вредности. Сваки пут када се позове функција над неким аргументом најпре се погледа да ли је вредност већ сачувана у табели, у ком случају се избегава излишно израчунавање. Ова стратегија, позната као <em>табулација</em> или <em>мемоизација</em>, може се имплементирати праволинијски. Табулација се понекад може користити за трансформисање поступака који захтевају експоненцијални број корака (као што је <code class="docutils literal notranslate"><span class="pre">кусур</span></code>) у поступке чији захтеви за простором и временом расту линеарно са порастом улаза. Више речи о мемоизацији биће у одељку о ефикасности у оквиру наредног поглавља.</p>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Садржај</a></h3>
  <ul>
<li><a class="reference internal" href="#">Рекурзивне функције</a><ul>
<li><a class="reference internal" href="#anatomyofrecursivefunctions">Анатомија рекурзивних функција</a></li>
<li><a class="reference internal" href="#mutualrecursion">Међусобна рекурзија</a></li>
<li><a class="reference internal" href="#printinginrecursivefunctions">Испис унутар рекурзивних функција</a></li>
<li><a class="reference internal" href="#treerecursion">Рекурзивно стабло</a></li>
<li><a class="reference internal" href="#examplepartitions">Пример: Партиције</a></li>
<li><a class="reference internal" href="#examplecountingchange">Пример: Враћање кусура</a></li>
</ul>
</li>
</ul>

  <h4>Претходни одељак</h4>
  <p class="topless"><a href="6-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%98%D0%B5-%D0%B2%D0%B8%D1%88%D0%B5%D0%B3-%D1%80%D0%B5%D0%B4%D0%B0.html"
                        title="претходна глава">Функције вишег реда</a></p>
  <h4>Следећи одељак</h4>
  <p class="topless"><a href="../%D0%B3%D0%BB%D0%B0%D0%B2%D0%B02/index.html"
                        title="наредна глава">Апстракција подацима</a></p>
  <div role="note" aria-label="source link">
    <h3>Ова страница</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/глава1/7-рекурзивне-функције.rst.txt"
            rel="nofollow">Изворни код</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Брза претрага</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Тражи" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Навигација</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >индекс</a></li>
        <li class="right" >
          <a href="../%D0%B3%D0%BB%D0%B0%D0%B2%D0%B02/index.html" title="Апстракција подацима"
             >напред</a> |</li>
        <li class="right" >
          <a href="6-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%98%D0%B5-%D0%B2%D0%B8%D1%88%D0%B5%D0%B3-%D1%80%D0%B5%D0%B4%D0%B0.html" title="Функције вишег реда"
             >назад</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">документација Компоновање рачунарских програма прво штампано</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Апстракција функцијама</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Рекурзивне функције</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020-2021, Владимир Миловановић.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.5.4.
    </div>
  </body>
</html>